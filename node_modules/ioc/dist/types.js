'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PropTypes = exports.TypedObject = exports.default = undefined;

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = types;
exports.TypedObject = TypedObject;
exports.PropTypes = _propTypes2.default;

// types decorator

function types(typeValidator) {
  return function (target, name) {
    target[name] = new TypedObject(typeValidator, target[name]);
    return target;
  };
}

// exportable object with type meta
function TypedObject(typeValidator, value) {
  this.type = typeValidator;
  this.value = value;
}

function typedObjectFactory(typeValidator) {

  // add extra step for combined types decorators
  if (typeValidator.name.match(/^create/)) {
    return function (details) {
      return function (target, name) {
        target[name] = new TypedObject(typeValidator(details), target[name]);
        return target;
      };
    };
  }

  return function (target, name) {
    target[name] = new TypedObject(typeValidator, target[name]);
    return target;
  };
}

// augment types with PropTypes values
(0, _keys2.default)(_propTypes2.default).forEach(function (key) {
  // only expose actual types and combined types
  // exclude helper properties
  if (['checkPropTypes', 'PropTypes'].indexOf(key) === -1) {
    types[key] = typedObjectFactory(_propTypes2.default[key]);

    // add isRequired
    if (_propTypes2.default[key].isRequired) {
      types[key].isRequired = typedObjectFactory(_propTypes2.default[key].isRequired);
    }
  }
});